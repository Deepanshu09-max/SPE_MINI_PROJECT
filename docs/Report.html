<hr />
<p>title: "SPE Miniproject Report"
author: "MT2024039 Deepanshu Saini"</p>
<hr />
<h3 id="quick-links">Quick links</h3>
<ul>
<li><a href="https://github.com/Deepanshu09-max/SPE_MINI_PROJECT">Github Repo</a></li>
<li><a href="https://hub.docker.com/repository/docker/deepanshu0903/calc-frontend/general">Calculator Frontend Image on Docker Hub</a></li>
<li><a href="https://hub.docker.com/repository/docker/deepanshu0903/calc-backend/general">Calculator Backend Image on Docker Hub</a></li>
</ul>
<hr />
<h3 id="problem-statement">Problem Statement</h3>
<p><img alt="Problem statement" src="./problem_statement.png" /></p>
<p>More details about the problem statement can be found in <a href="./Mini%20Project_Scientific%20Calculator.pdf">this</a> document.</p>
<hr />
<h3 id="devops">DevOps</h3>
<p><strong>What is DevOps</strong><br />
<a href="https://www.atlassian.com/devops">DevOps</a> is a set of practices, tools, and cultural philosophies that automate and integrate processes between software development and IT operations teams. Its primary goal is to deliver high-quality software faster and more reliably through collaboration, automation, and continuous improvement.</p>
<p><strong>Main Aspects of DevOps</strong><br />
- <strong>Collaboration and Communication</strong>: DevOps fosters a culture where development, operations, and other stakeholders (like QA and security teams) work together from the start of a project.<br />
- <strong>Shared Responsibility</strong>: Everyone involved takes collective responsibility for the entire lifecycle of the application, from development to deployment and maintenance.<br />
- <strong>Continuous Integration (CI)</strong>: Automating the process of integrating code changes into a shared repository, ensuring that new code is automatically built and tested.<br />
- <strong>Continuous Delivery/Deployment (CD)</strong>: Automating the release process to deploy code changes quickly and safely to production or staging environments.<br />
- <strong>Version Control Systems</strong>: Systems like Git are the backbone of modern DevOps, providing a way to track changes, collaborate on code, and manage releases.</p>
<p>This approach bridges the gap between Development and Operations, leveraging each team’s strengths. The entire team works across the application lifecycle, illustrated by the loop diagram below:</p>
<p><img alt="DevOps loop" src="./devops_loop.jpeg" /></p>
<p><strong>Why DevOps?</strong><br />
Some key benefits of DevOps relevant to our project:
- <strong>Faster and Better Product Delivery</strong>: Enables safe agility and rapid iteration.<br />
- <strong>Faster Issue Resolution</strong>: Automated CI pipelines and user-friendly tooling reduce the manual overhead of debugging.<br />
- <strong>Greater Automation</strong>: Minimizes repetitive tasks, like manual pushing to package managers or running tests locally.</p>
<hr />
<h3 id="tools-used">Tools Used</h3>
<ul>
<li><strong>Git</strong><br />
  A distributed version control system. We used GitHub for commits and issue tracking.</li>
<li><strong>Python</strong><br />
  The primary language for our scientific calculator application.</li>
<li><strong>Pytest</strong><br />
  A Python testing tool for unit tests in the calculator functions.</li>
<li><strong>Docker</strong><br />
  A containerization platform for packaging our project into lightweight containers.</li>
<li><strong>Jenkins</strong><br />
  An open-source automation server that helps implement CI/CD workflows.</li>
<li><strong>Ansible</strong><br />
  A configuration management tool for automating deployments and infrastructure tasks.</li>
<li><strong>FastAPI</strong><br />
  A high-performance Python web framework for serving the calculator’s functionalities.</li>
<li><strong>Shell Scripting</strong><br />
  Used to automate routine deployment and system configuration tasks.</li>
<li><strong>Docker Compose</strong><br />
  Defines and runs multiple Docker containers as a single application.</li>
<li><strong>HTML</strong><br />
  Structures and displays the calculator’s frontend.</li>
</ul>
<hr />
<h3 id="project-structure">Project Structure</h3>
<p><img alt="Project Structure" src="./tree.png" /></p>
<ul>
<li><strong><code>backend/Calculator.py</code></strong> contains the Python code for the calculator’s logic.</li>
<li><strong><code>devops/</code></strong> holds essential DevOps artifacts (e.g., <code>Jenkinsfile</code>, <code>calc-playbook.yml</code>, <code>docker-compose.yml</code>, etc.).</li>
<li><strong><code>Dockerfile</code></strong> files define how to containerize the backend and frontend.</li>
<li><strong><code>calc-playbook.yml</code></strong> and <strong><code>inventory</code></strong> manage local or remote deployment via Ansible.</li>
</ul>
<hr />
<h3 id="code-snippets">Code Snippets</h3>
<p><img alt="Python code" src="./calc.png" /></p>
<p>Key aspects of the Python backend code:
- Edge-case handling (e.g., negative numbers for square roots).
- Computation of required functionalities (factorial, log, power, etc.).
- Logging of inputs and outputs.</p>
<hr />
<h3 id="tests">Tests</h3>
<p><img alt="Test code" src="./test.png" /></p>
<p>Key aspects of the test code:
- Unit tests for each calculator function.
- Validation of edge cases and correct results.
- Execution via Pytest for quick feedback.</p>
<hr />
<h2 id="local-installation-and-setup">⚙️ Local Installation and Setup</h2>
<ol>
<li>
<p><strong>Clone the Repository</strong>
    <code>bash
    git clone https://github.com/AryanRastogi7767/Scientific_Calculator.git</code></p>
</li>
<li>
<p><strong>Install Required Packages</strong>
    <code>bash
    pip install -r requirements.txt</code></p>
</li>
<li>
<p><strong>Launch the FastAPI Server</strong>
    <code>bash
    uvicorn calculator:app --host 0.0.0.0 --port 8000</code></p>
</li>
<li>
<p><strong>Execute the Tests</strong>
    <code>bash
    pytest test.py --tb=short --disable-warnings</code></p>
</li>
</ol>
<h1 id="devops-workflow-docker-jenkins-and-ansible-integration">DevOps Workflow: Docker, Jenkins, and Ansible Integration</h1>
<h2 id="1-docker-build-and-run">1. Docker: Build and Run</h2>
<h3 id="backend-dockerfile">Backend Dockerfile</h3>
<p><img alt="Dockerfile" src="./docker-back.png" />
This Dockerfile creates an image for our Python-based backend application.</p>
<ul>
<li>Uses a lightweight Python base image (e.g., <code>python:3.9-slim</code>).</li>
<li>Copies Python code and installs dependencies.</li>
<li>Exposes port <code>8000</code> and runs the FastAPI/Flask server.</li>
</ul>
<p><strong>Running the Backend Container:</strong></p>
<pre class="codehilite"><code class="language-bash">docker run -d --name my-calc-back --network spe-mp -p 8000:8000 calc-backend
</code></pre>

<h3 id="frontend-dockerfile">Frontend Dockerfile</h3>
<p><img alt="Dockerfile" src="./docker-front.png" />
This Dockerfile creates an image for our HTML-based frontend application.</p>
<ul>
<li>Uses an Nginx base image (<code>nginx:alpine</code>).</li>
<li>Copies static <code>HTML/CSS/JS</code> into Nginx’s <code>/usr/share/nginx/html</code>.</li>
<li>Exposes port <code>80</code> for serving frontend files.</li>
</ul>
<p><strong>Running the Frontend Container:</strong></p>
<pre class="codehilite"><code class="language-bash">docker run -d --name my-calc-front --network spe-mp -p 3000:80 calc-frontend
</code></pre>

<hr />
<h2 id="2-docker-compose-managing-multiple-containers">2. Docker Compose: Managing Multiple Containers</h2>
<p><img alt="Dockerfile" src="./docker-compose.png" /></p>
<p>A <code>docker-compose.yml</code> file is used to orchestrate the backend and frontend services.</p>
<ul>
<li>Defines two services: <strong>backend (Python server)</strong> and <strong>frontend (Nginx)</strong>.</li>
<li>Specifies <strong>images</strong> (or build contexts) and <strong>port mappings</strong> (<code>8000:8000</code> and <code>3000:80</code>).</li>
<li>Creates a <strong>shared network</strong> to allow frontend-backend communication using service names.</li>
</ul>
<p><strong>Build and Start Containers:</strong></p>
<pre class="codehilite"><code class="language-bash">docker compose build
</code></pre>

<hr />
<h2 id="3-pushing-docker-images-to-docker-hub">3. Pushing Docker Images to Docker Hub</h2>
<p>After building the images, we push them to Docker Hub for easy deployment.</p>
<ol>
<li><strong>Login to Docker Hub:</strong></li>
</ol>
<pre class="codehilite"><code class="language-bash">docker login -u &lt;your-username&gt; -p &lt;your-password&gt;
</code></pre>

<ol>
<li><strong>Tag the image for Docker Hub:</strong></li>
</ol>
<pre class="codehilite"><code class="language-bash">docker tag my-image &lt;dockerhub-username&gt;/&lt;repo-name&gt;:&lt;tag&gt;
</code></pre>

<ol>
<li><strong>Push the image to Docker Hub:</strong></li>
</ol>
<pre class="codehilite"><code class="language-bash">docker push &lt;dockerhub-username&gt;/&lt;repo-name&gt;:&lt;tag&gt;
</code></pre>

<hr />
<h2 id="4-jenkins-cicd-setup">4. Jenkins: CI/CD Setup</h2>
<h3 id="installing-jenkins">Installing Jenkins</h3>
<h4 id="prerequisites">Prerequisites:</h4>
<ul>
<li><strong>OS:</strong> Ubuntu (or Debian-based distros)</li>
<li><strong>Java:</strong> Jenkins requires Java 11 or later.</li>
</ul>
<h4 id="installation-steps">Installation Steps:</h4>
<p><img alt="Jenkins" src="./jenkins.png" /></p>
<h3 id="a-install-java">A. Install Java</h3>
<pre class="codehilite"><code class="language-bash">sudo apt-get update
sudo apt-get install -y openjdk-11-jdk
</code></pre>

<h3 id="b-install-jenkins">B. Install Jenkins</h3>
<pre class="codehilite"><code class="language-bash">sudo apt-get update
sudo apt-get install -y jenkins
</code></pre>

<h3 id="c-start-and-check-jenkins">C. Start and Check Jenkins</h3>
<pre class="codehilite"><code class="language-bash">sudo systemctl start jenkins
sudo systemctl status jenkins
</code></pre>

<p>Jenkins listens on port 8080 by default. Visit <code>http://&lt;your-server-ip&gt;:8080</code> to access the Jenkins UI.</p>
<h4 id="jenkins-pipeline-jenkinsfile">Jenkins Pipeline (Jenkinsfile)</h4>
<ul>
<li>Checks out code, runs Python tests, builds Docker images, logs into Docker Hub, pushes images, and triggers Ansible.</li>
<li>Each step is defined in a stage ensuring a clear, sequential flow.</li>
<li>Automates CI/CD, ensuring every commit leads to a consistent build and deployment.</li>
</ul>
<hr />
<h2 id="5-ansible-setup-and-usage">5. Ansible Setup and Usage</h2>
<h3 id="installing-ansible">Installing Ansible</h3>
<h4 id="prerequisites_1">Prerequisites:</h4>
<ul>
<li><strong>OS:</strong> Ubuntu (or another Linux distro)</li>
<li><strong>Python 3:</strong> Required for Ansible execution.</li>
</ul>
<h4 id="installation-steps_1">Installation Steps:</h4>
<pre class="codehilite"><code class="language-bash">sudo apt-get update
sudo apt-get install -y ansible
</code></pre>

<h3 id="inventory-file">Inventory File</h3>
<p>Defines target hosts.</p>
<pre class="codehilite"><code class="language-ini">[myservers]
192.168.1.10 ansible_user=ubuntu
</code></pre>

<h3 id="playbookyml">Playbook.yml</h3>
<p><img alt="Playbook" src="./ansible.png" /></p>
<p>Ansible playbook automates container deployment:
- Pulls the latest Docker images (backend &amp; frontend) from Docker Hub.
- Runs them on a remote host.
- Uses Docker tasks or Docker Compose for container management.
- Jenkins triggers this after successful build and push.</p>
<p><strong>Execute Playbook:</strong></p>
<pre class="codehilite"><code class="language-bash">ansible-playbook -i inventory calc-playbook.yml
</code></pre>

<hr />
<h2 id="email-notification-script">Email Notification Script</h2>
<p>At the end of our Jenkins pipeline, we have an <strong>email script</strong> that automatically sends out a color-coded HTML email indicating the pipeline’s status. This script is placed in the pipeline’s <strong><code>post { always { ... } }</code></strong> block, ensuring it runs whether the build succeeds or fails. The key points are:
<img alt="email" src="./email-script.png" />
<img alt="email2" src="./email-notif.png" /></p>
<ol>
<li><strong>Jenkins Email Extension Plugin</strong>: We use <code>emailext</code> to send emails with an HTML body.</li>
<li><strong>Dynamic Subject &amp; Body</strong>: The script reads environment variables like <code>JOB_NAME</code> and <code>BUILD_NUMBER</code>, then constructs an HTML message indicating success or failure.</li>
<li><strong>Color-Coded Results</strong>: If the build succeeds, a green banner appears; if it fails, it’s red—providing a quick visual cue of the pipeline outcome.</li>
<li><strong>Console Link</strong>: The email includes a link to the Jenkins console logs, making it easy for recipients to review details or troubleshoot.</li>
<li><strong>Guaranteed Execution</strong>: Because it’s in a <code>post { always { ... } }</code> block, the email fires at the end of every run, even if earlier stages fail.</li>
</ol>
<h2 id="by-combining-these-features-our-email-script-keeps-us-informed-of-every-pipeline-run-ensuring-quick-visibility-into-build-statuses-and-any-required-follow-up">By combining these features, our email script keeps us informed of every pipeline run, ensuring quick visibility into build statuses and any required follow-up.</h2>
<h2 id="conclusion">Conclusion</h2>
<p>Here are some final lines summarizing next steps and confirming your project is ready:
<img alt="piepeline" src="./pipeline-view.png" /></p>
<ol>
<li>Your project is fully containerized, separating backend and frontend services.</li>
<li>Jenkins now builds and pushes your Docker images automatically.</li>
<li>Ansible pulls and deploys the latest images on demand, ensuring a consistent environment.</li>
<li>Docker Compose can orchestrate multiple containers seamlessly.</li>
<li>Each commit triggers a reliable, repeatable CI/CD pipeline.</li>
<li>You can view pipeline stages and logs in the Jenkins dashboard for easy debugging.</li>
<li>Any new changes automatically update the running containers, streamlining your release process.</li>
<li>A post-step email script sends a color-coded HTML email, highlighting success or failure with a direct link to console logs.</li>
<li>This email notification helps your team stay informed of pipeline results at a glance.</li>
<li>Simply trigger a new Jenkins build, and your application will be deployed and ready to go!</li>
</ol>